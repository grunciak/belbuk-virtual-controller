# Schemat GraphQL wirtualnego sterownika Belbuk
# Zgodny z zapytaniami: Configuration.graphql, Authorization.graphql, Mutation.graphql

type Query {
  # Autoryzacja
  getAuthToken(login: String!, password: String!): AuthToken
  refreshAuthToken: AuthToken
  
  # Konfiguracja
  configuration: Configuration
  authorization: Authorization
  resource(points: [ID!], groups: [ID!]): Resource
  
  # Zdarzenia
  getUnconfirmedEvents: [ID!]
  
  # Inne
  tokenTTL: Int!
}

type Mutation {
  # System
  echoEvent: String
  setSiteIdentifier(id: ID!): Boolean
  setTokenTTL(ttl: Int!): Boolean
  
  # Harmonogramy
  createScheduler(input: [InputCreateScheduler!]!): [Scheduler!]
  deleteScheduler(id: [Int!]!): Boolean
  modifyScheduler(input: [InputModifyScheduler!]!): [Scheduler!]
  
  # Dni specjalne
  createSpecialDay(input: [InputCreateSpecialDay!]!): [SpecialDay!]
  modifySpecialDay(input: [InputModifySpecialDay!]!): [SpecialDay!]
  deleteSpecialDay(id: [Int!]!): Boolean
  
  # Poziomy dostępu
  createAccessLevel(input: [InputCreateAccessLevel!]!): [AccessLevel!]
  modifyAccessLevel(input: [InputModifyAccessLevel!]!): [AccessLevel!]
  deleteAccessLevel(id: [Int!]!): Boolean
  
  # Użytkownicy
  createUser(input: [InputCreateUser!]!): [User!]
  modifyUser(input: [InputModifyUser!]!): [User!]
  deleteUser(id: [Int!]!): Boolean
  
  # Autoryzacja zbiorcza
  updateAuthorization(input: InputUpdateAuthorization!): Authorization
  
  # Zdarzenia
  confirmEvent(id: [ID!]!): [EventConfirmation!]
  
  # Sterowanie strefami
  controlZone(zone: Int!, override: ControlZoneResult, operator: Int!): ControlZoneResult
  restoreZone(zone: Int!, operator: Int!): RestoreAlarmResult
  testZone(zone: Int!, operator: Int!): TestZoneResult
  blockZone(zone: Int!, operator: Int!): BlockZoneResult
  blockZoneSensor(sensor: Int!, operator: Int!): BlockZoneSensorResult
  unblockZoneSensor(sensor: Int!, operator: Int!): UnblockZoneSensorResult
  
  # Sterowanie przejściami
  releasePortal(portal: Int!, operator: Int!): ReleasePortalResult
  emergencyPortal(portal: Int!, operator: Int!): EmergencyPortalResult
  restorePortal(portal: Int!, operator: Int!): RestorePortalResult
  
  # Antypassback
  suspendAntipassback(operator: Int!): ManageAntipassbackResult
  resumeAntipassback(operator: Int!): ManageAntipassbackResult
  reactivateAntipassback(credential: String, operator: Int!): ReactivateAntipassbackResult
}

type Subscription {
  events: Event
}

# ==================== AUTORYZACJA ====================

type AuthToken {
  mainToken: String
  refreshToken: String
}

# ==================== CONFIGURATION ====================

type Configuration {
  site: ID
  inputs: [Input!]!
  outputs: [Output!]!
  readers: [Reader!]!
  zones: [Zone!]!
  portals: [Portal!]!
  faults: [Fault!]!
  events: [EventType!]!
}

type Input {
  id: ID!
  name: String!
}

type Output {
  id: ID!
  name: String!
}

type Reader {
  id: ID!
  name: String!
}

type Zone {
  id: ID!
  name: String!
  controls: [Reader!]
  detectors: [Detector!]
  alarms: [Alarm!]
}

type Detector {
  input: Input!
  entryTime: Int
  exitTime: Int
}

type Alarm {
  output: Output!
  time: Int
}

type Portal {
  id: ID!
  name: String!
  entry: Reader
  exit: Reader
  button: Input
  locking: Output
  sensor: Input
  release: Int
  emergencies: [Input!]
}

type Fault {
  fault: FaultType
  inputs: [Input!]
}

enum FaultType {
  TAMPER
  PRIME_POWER_SUPPLY
  ALTERNATIVE_POWER_SUPPLY
  HARDWARE
}

type EventType {
  code: Int!
  symbol: String!
  desc: String!
}

# ==================== AUTHORIZATION ====================

type Authorization {
  schedulers: [Scheduler!]!
  derogations: [SpecialDay!]!
  access: [AccessLevel!]!
  users: [User!]!
}

type Scheduler {
  id: Int!
  name: String!
  periods: [Period!]!
}

type Period {
  day: Int!
  start: String!
  end: String!
}

type SpecialDay {
  id: Int!
  date: String!
  day: Int!
}

type AccessLevel {
  id: Int!
  name: String!
  zones: [ZoneAccess!]
  portals: [PortalAccess!]
}

type ZoneAccess {
  zone: Zone!
  scheduler: Scheduler
  arm: Boolean
  disarm: Boolean
  test: Boolean
}

type PortalAccess {
  portal: Portal!
  scheduler: Scheduler
}

type User {
  id: Int!
  name: String!
  credential: Credential
  expire: String
  restore: Boolean
  override: Boolean
  access: [AccessLevel!]
}

type Credential {
  card: String
  pin: String
}

# ==================== RESOURCE ====================

type Resource {
  points: [Point!]
  groups: [PointGroup!]
}

type Point {
  id: String!
  name: String!
  type: String
  family: String
  created: String
  value: PointValue
}

type PointValue {
  type: String
  value: String
}

type PointGroup {
  id: String!
  name: String!
  leader: Point
  points: [Point!]
  groups: [PointGroup!]
}

# ==================== EVENTS ====================

type Event {
  site: String!
  id: ID!
  dateTime: String!
  trigger: EventTrigger
  reason: Point
  points: [Point!]
  extensions: [EventExtension!]
  user: EventUser
  operator: Int
}

type EventTrigger {
  type: Int!
  template: String
}

type EventExtension {
  id: String
  type: String
  value: String
}

type EventUser {
  id: Int
  name: String
}

type EventConfirmation {
  id: ID!
  status: String
}

# ==================== INPUT TYPES ====================

input InputCreateScheduler {
  name: String!
  periods: [InputPeriod!]!
}

input InputModifyScheduler {
  id: Int!
  name: String
  periods: [InputPeriod!]
}

input InputPeriod {
  day: Int!
  start: String!
  end: String!
}

input InputCreateSpecialDay {
  date: String!
  day: Int!
}

input InputModifySpecialDay {
  id: Int!
  date: String
  day: Int
}

input InputCreateAccessLevel {
  name: String!
  zones: [InputZoneAccess!]
  portals: [InputPortalAccess!]
}

input InputModifyAccessLevel {
  id: Int!
  name: String
  zones: [InputZoneAccess!]
  portals: [InputPortalAccess!]
}

input InputZoneAccess {
  zone: Int!
  scheduler: Int
  arm: Boolean
  disarm: Boolean
  test: Boolean
}

input InputPortalAccess {
  portal: Int!
  scheduler: Int
}

input InputCreateUser {
  name: String!
  credential: InputCredential
  expire: String
  restore: Boolean
  override: Boolean
  access: [Int!]
}

input InputModifyUser {
  id: Int!
  name: String
  credential: InputCredential
  expire: String
  restore: Boolean
  override: Boolean
  access: [Int!]
}

input InputCredential {
  card: String
  pin: String
}

input InputUpdateAuthorization {
  schedulers: [InputModifyScheduler!]
  derogations: [InputModifySpecialDay!]
  access: [InputModifyAccessLevel!]
  users: [InputModifyUser!]
}

# ==================== ENUMS ====================

enum ControlZoneResult {
  BLOCKED_BACKUP
  BLOCKED_FAULT
  BLOCKED_MAINS
  BLOCKED_SENSOR
  BLOCKED_TAMPER
  UNKNOWN
  ZONE_ARMED
  ZONE_DISARMED
  ZONE_TEST_ENDED
  ZONE_UNBLOCKED
}

enum RestoreAlarmResult {
  UNKNOWN
  RESTORED
  STILL_ALARM_CONDITION
  ALARM_NOT_ACTIVE
}

enum TestZoneResult {
  UNKNOWN
  STARTED
  ALREADY_STARTED
  DISARM_REQUIRED
}

enum BlockZoneResult {
  UNKNOWN
  BLOCKED
  ALREADY_BLOCKED
  DISARM_REQUIRED
}

enum BlockZoneSensorResult {
  UNKNOWN
  BLOCKED
  ALREADY_BLOCKED
  NOT_SENSOR
}

enum UnblockZoneSensorResult {
  UNKNOWN
  UNBLOCKED
  ALREADY_UNBLOCKED
  NOT_SENSOR
}

enum ReleasePortalResult {
  UNKNOWN
  RELEASED
  EMERGENCY
}

enum EmergencyPortalResult {
  UNKNOWN
  DONE
  ALREADY_EMERGENCY
}

enum RestorePortalResult {
  UNKNOWN
  RESTORED
  STILL_EMERGENCY_CONDITION
  NORMAL_OPERATION
}

enum ManageAntipassbackResult {
  UNKNOWN
  ALREADY_SUSPENDED
  SUSPENDED
  ALREADY_RESUMED
  RESUMED
}

enum ReactivateAntipassbackResult {
  UNKNOWN
  REACTIVATED
}
