# Schemat GraphQL wirtualnego kontrolera Belbuk

scalar DateTime

# ==================== TYPY WARTOŚCI ====================

enum ValueType {
  BOOLEAN
  INTEGER
  DOUBLE
  MULTIVAL
  USERID
}

type PointValue {
  type: ValueType
  value: String
}

# ==================== KONFIGURACJA ====================

type Input {
  id: String!
  name: String!
}

type Output {
  id: String!
  name: String!
}

type Reader {
  id: String!
  name: String!
}

type Detector {
  input: Input!
  entryTime: Int
  exitTime: Int
}

type Alarm {
  output: Output!
  time: Int
}

type Zone {
  id: String!
  name: String!
  controls: [Input!]
  detectors: [Detector!]
  alarms: [Alarm!]
}

type Portal {
  id: String!
  name: String!
  entry: Reader
  exit: Reader
  button: Input
  locking: Output
  sensor: Input
  release: Int
  emergencies: [Output!]
}

type Fault {
  fault: String!
  inputs: [Input!]
}

type EventDef {
  code: Int!
  symbol: String!
  desc: String!
}

type Configuration {
  site: String!
  inputs: [Input!]!
  outputs: [Output!]!
  readers: [Reader!]!
  zones: [Zone!]!
  portals: [Portal!]!
  faults: [Fault!]
  events: [EventDef!]!
}

# ==================== ZASOBY (PUNKTY) ====================

type Point {
  id: ID!
  name: String!
  type: String!
  family: String!
  created: String
  value: PointValue
}

type Group {
  id: ID!
  name: String!
  leader: Point
  points: [Point!]
  groups: [Group!]
}

type Resource {
  points: [Point!]
  groups: [Group!]
}

# ==================== AUTORYZACJA ====================

type Period {
  day: Int!
  start: String!
  end: String!
}

type Scheduler {
  id: Int!
  name: String!
  periods: [Period!]
}

type SpecialDay {
  id: Int!
  date: String!
  day: Int!
}

type ZoneAccess {
  zone: Zone!
  scheduler: Scheduler
  arm: Boolean
  disarm: Boolean
  test: Boolean
}

type PortalAccess {
  portal: Portal!
  scheduler: Scheduler
}

type AccessLevel {
  id: Int!
  name: String!
  zones: [ZoneAccess!]
  portals: [PortalAccess!]
}

type Credential {
  card: String
  pin: String
}

type User {
  id: Int!
  name: String!
  credential: Credential
  expire: String
  restore: Boolean
  override: Boolean
  access: [AccessLevel!]
}

type Authorization {
  schedulers: [Scheduler!]
  derogations: [SpecialDay!]
  access: [AccessLevel!]
  users: [User!]
}

type AuthToken {
  mainToken: String!
  refreshToken: String!
}

# ==================== ZDARZENIA ====================

type Trigger {
  type: Int
  template: String
}

type EventExtension {
  id: Int
  type: Int
  value: String
}

type EventUser {
  id: Int!
  name: String!
}

type EventConfirmation {
  id: ID!
  status: String
}

type Event {
  site: String
  id: ID!
  dateTime: String!
  trigger: Trigger
  reason: Point
  points: [Point!]
  extensions: [EventExtension!]
  user: EventUser
  operator: Int
}

# ==================== REZULTATY OPERACJI ====================

enum ControlZoneResult {
  ZONE_ARMED
  ZONE_DISARMED
  ZONE_TEST_ENDED
  ZONE_UNBLOCKED
  BLOCKED_SENSOR
  BLOCKED_TAMPER
  BLOCKED_FAULT
  BLOCKED_MAINS
  BLOCKED_BACKUP
  UNKNOWN
}

enum RestoreAlarmResult {
  RESTORED
  ALARM_NOT_ACTIVE
  STILL_ALARM_CONDITION
  UNKNOWN
}

enum TestZoneResult {
  STARTED
  ALREADY_STARTED
  DISARM_REQUIRED
  UNKNOWN
}

enum BlockZoneResult {
  BLOCKED
  ALREADY_BLOCKED
  DISARM_REQUIRED
  UNKNOWN
}

enum BlockZoneSensorResult {
  BLOCKED
  ALREADY_BLOCKED
  NOT_SENSOR
  UNKNOWN
}

enum UnblockZoneSensorResult {
  UNBLOCKED
  ALREADY_UNBLOCKED
  NOT_SENSOR
  UNKNOWN
}

enum ReleasePortalResult {
  RELEASED
  EMERGENCY
  UNKNOWN
}

enum EmergencyPortalResult {
  DONE
  ALREADY_EMERGENCY
  UNKNOWN
}

enum RestorePortalResult {
  RESTORED
  NORMAL_OPERATION
  STILL_EMERGENCY_CONDITION
  UNKNOWN
}

enum ManageAntipassbackResult {
  SUSPENDED
  RESUMED
  ALREADY_SUSPENDED
  ALREADY_RESUMED
  UNKNOWN
}

enum ReactivateAntipassbackResult {
  REACTIVATED
  UNKNOWN
}

# ==================== INPUTY ====================

input InputCreateScheduler {
  name: String!
  periods: [PeriodInput!]!
}

input InputModifyScheduler {
  id: Int!
  name: String
  periods: [PeriodInput!]
}

input PeriodInput {
  day: Int!
  start: String!
  end: String!
}

input InputCreateSpecialDay {
  date: String!
  day: Int!
}

input InputModifySpecialDay {
  id: Int!
  date: String
  day: Int
}

input InputCreateAccessLevel {
  name: String!
  zones: [ZoneAccessInput!]
  portals: [PortalAccessInput!]
}

input InputModifyAccessLevel {
  id: Int!
  name: String
  zones: [ZoneAccessInput!]
  portals: [PortalAccessInput!]
}

input ZoneAccessInput {
  zoneId: Int!
  schedulerId: Int
  arm: Boolean
  disarm: Boolean
  test: Boolean
}

input PortalAccessInput {
  portalId: Int!
  schedulerId: Int
}

input InputCreateUser {
  name: String!
  card: String
  pin: String
  expire: String
  restore: Boolean
  override: Boolean
  accessLevelIds: [Int!]
}

input InputModifyUser {
  id: Int!
  name: String
  card: String
  pin: String
  expire: String
  restore: Boolean
  override: Boolean
  accessLevelIds: [Int!]
}

input InputUpdateAuthorization {
  schedulers: [InputModifyScheduler!]
  derogations: [InputModifySpecialDay!]
  access: [InputModifyAccessLevel!]
  users: [InputModifyUser!]
}

# ==================== QUERY ====================

type Query {
  configuration: Configuration!
  resource(points: [ID!], groups: [ID!]): Resource!
  authorization: Authorization!
  getAuthToken(login: String!, password: String!): AuthToken!
  refreshAuthToken: AuthToken!
  getUnconfirmedEvents: [Event!]!
  getControllerInfo: ControllerInfo!
}

type ControllerInfo {
  globalControllerIdentifier: String!
  apiUrl: String!
  subscriptionUrl: String!
  apiUser: String
  apiPassword: String
  token: String
  activeSubscription: Boolean!
}

# ==================== MUTATION ====================

type Mutation {
  # Echo/test
  echoEvent: String
  
  # Konfiguracja
  setSiteIdentifier(id: ID!): Boolean!
  setTokenTTL(ttl: Int!): Boolean!
  
  # Harmonogramy
  createScheduler(input: [InputCreateScheduler!]!): [Scheduler!]!
  modifyScheduler(input: [InputModifyScheduler!]!): [Scheduler!]!
  deleteScheduler(id: [Int!]!): Boolean!
  
  # Dni specjalne
  createSpecialDay(input: [InputCreateSpecialDay!]!): [SpecialDay!]!
  modifySpecialDay(input: [InputModifySpecialDay!]!): [SpecialDay!]!
  deleteSpecialDay(id: [Int!]!): Boolean!
  
  # Poziomy dostępu
  createAccessLevel(input: [InputCreateAccessLevel!]!): [AccessLevel!]!
  modifyAccessLevel(input: [InputModifyAccessLevel!]!): [AccessLevel!]!
  deleteAccessLevel(id: [Int!]!): Boolean!
  
  # Użytkownicy
  createUser(input: [InputCreateUser!]!): [User!]!
  modifyUser(input: [InputModifyUser!]!): [User!]!
  deleteUser(id: [Int!]!): Boolean!
  
  # Aktualizacja całej autoryzacji
  updateAuthorization(input: InputUpdateAuthorization!): Authorization!
  
  # Sterowanie strefami
  controlZone(zone: Int!, override: ControlZoneResult, operator: Int!): ControlZoneResult!
  restoreZone(zone: Int!, operator: Int!): RestoreAlarmResult!
  testZone(zone: Int!, operator: Int!): TestZoneResult!
  blockZone(zone: Int!, operator: Int!): BlockZoneResult!
  blockZoneSensor(sensor: Int!, operator: Int!): BlockZoneSensorResult!
  unblockZoneSensor(sensor: Int!, operator: Int!): UnblockZoneSensorResult!
  
  # Sterowanie przejściami
  releasePortal(portal: Int!, operator: Int!): ReleasePortalResult!
  emergencyPortal(portal: Int!, operator: Int!): EmergencyPortalResult!
  restorePortal(portal: Int!, operator: Int!): RestorePortalResult!
  
  # Antypassback
  suspendAntipassback(operator: Int!): ManageAntipassbackResult!
  resumeAntipassback(operator: Int!): ManageAntipassbackResult!
  reactivateAntipassback(credential: String, operator: Int!): ReactivateAntipassbackResult!
  
  # Zdarzenia
  confirmEvent(id: [ID!]!): [EventConfirmation!]!
}

# ==================== SUBSCRIPTION ====================

type Subscription {
  events: Event!
}
